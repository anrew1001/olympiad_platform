# Техническое обоснование проекта (Project Reasoning)

## 1. Основная архитектура

Проект построен на современной микросервисной архитектуре, разделяющей Frontend и Backend, что обеспечивает гибкость разработки, масштабируемость и высокую производительность.

### Технологический стек

*   **Backend: FastAPI (Python)**
    *   **Почему FastAPI:** Это один из самых быстрых фреймворков на Python, поддерживающий асинхронность (`asyncio`) "из коробки". Это критически важно для нашей платформы, так как PvP-режим требует обработки множества одновременных WebSocket-соединений с минимальными задержками.
    *   **Преимущества:** Строгая типизация через Pydantic гарантирует валидацию данных на входе, а автогенерируемая документация (Swagger UI) ускоряет интеграцию с фронтендом.
*   **Frontend: Next.js (React)**
    *   **Почему Next.js:** Использование Server-Side Rendering (SSR) и React Server Components позволяет отдавать пользователю готовые HTML-страницы, что улучшает SEO и скорость первичной загрузки (LCP).
    *   **Интерактивность:** Клиентские компоненты React обеспечивают мгновенный отклик интерфейса при решении задач и взаимодействии в реальном времени.

### Взаимодействие
Backend и Frontend общаются через REST API для стандартных операций (авторизация, получение задач) и через WebSocket для событий реального времени (обновление счета в матче, поиск соперника).

---

## 2. Эволюция базы данных

Изначально проект мог использовать простые SQL-скрипты для создания таблиц (`recreate_tables.py`). Однако по мере роста сложности системы и добавления PvP-функционала, такой подход стал неприемлем из-за риска потери данных и сложности поддержки версионности схемы.

### Переход на Alembic
Мы внедрили **Alembic** — инструмент для управления миграциями базы данных.
*   **Контроль версий:** Каждое изменение структуры БД (добавление таблицы `matches`, индекса и т.д.) фиксируется в отдельном файле миграции. Это позволяет легко откатывать изменения и синхронизировать состояние БД между разработчиками.
*   **Асинхронность:** Alembic настроен на работу с асинхронным драйвером `asyncpg`, что соответствует архитектуре FastAPI приложения.
*   **Обработка новых моделей:** При добавлении PvP-моделей Alembic автоматически обнаружил новые классы (`Match`, `MatchAnswer`) и сгенерировал SQL-команды для их создания, включая сложные внешние ключи и уникальные индексы.

---

## 3. Разбор моделей данных

Архитектура данных спроектирована с учетом нормализации и целостности связей.

### Базовая логика задач (Core)
Эта часть системы отвечает за индивидуальное обучение пользователя.
1.  **`User`**: Центральная сущность. Хранит учетные данные и текущий рейтинг Elo.
2.  **`Task`**: Содержит контент задачи (текст, ответ, сложность). Поле `answer` хранится в БД, но никогда не отдается на клиент в "сыром" виде.
3.  **`UserTaskAttempt`**: Журнал действий. Связывает Пользователя и Задачу.
    *   *Связь:* Один-ко-многим (User -> Attempts).
    *   *Назначение:* Позволяет строить аналитику, рассчитывать процент правильных решений и выдавать достижения.

### Логика PvP-матчей
Эта часть реализует соревновательную механику реального времени.
1.  **`Match`**: Сессия игры. Связывает двух игроков (`player1_id`, `player2_id`).
    *   Хранит текущее состояние (`status`), счет и результат (`winner_id`, `rating_change`).
2.  **`MatchTask`**: Определяет набор задач для конкретного матча.
    *   *Связь:* Многие-ко-многим (Match <-> Task) через промежуточную таблицу.
    *   *Поле `order`:* Гарантирует, что оба игрока получают задачи в одинаковом порядке, что критично для честности соревнования.
3.  **`MatchAnswer`**: Ответы в рамках матча.
    *   Отличается от `UserTaskAttempt` тем, что привязан к конкретному матчу.
    *   *Уникальность:* Индекс `(match_id, user_id, task_id)` гарантирует, что в рамках одного матча пользователь может иметь только один "зачтенный" (или последний) ответ на задачу. Повторная отправка обновляет запись, а не создает дубликат.

### Обоснование индексов
Для обеспечения высокой производительности (High Performance) были добавлены специфические индексы:
*   **`Match.status`**:
    *   *Зачем:* Система матчмейкинга (Matchmaking) постоянно ищет матчи со статусом `WAITING`. Индекс превращает этот поиск из полного сканирования таблицы (Full Scan) в мгновенный поиск по B-Tree (Index Scan).
*   **`MatchTask.order`**:
    *   *Зачем:* При начале матча фронтенд запрашивает задачи. Сортировка по индексированному полю `order` происходит на порядок быстрее, гарантируя, что пользователи не будут ждать загрузки списка задач.

---

## 4. Безопасность и производительность

### Безопасность данных
*   **Валидация на уровне БД:** Использование `Foreign Keys` с каскадным удалением (`CASCADE` или `SET NULL`) предотвращает появление "сиротских" записей. Например, если удалить Матч, автоматически удалятся и ответы к нему.
*   **Изоляция ответов:** Правильные ответы (`Task.answer`) никогда не передаются на фронтенд. Проверка происходит исключительно на сервере.
*   **Защита от читерства:** Уникальные индексы предотвращают спам ответами для накрутки очков.

### Производительность поиска (Matchmaking)
Алгоритм поиска соперника опирается на быстрые SQL-запросы:
1.  Найти матч со статусом `WAITING`.
2.  Отфильтровать по диапазону рейтинга (например, `User.rating +/- 200`).
Благодаря индексам на `status` и `rating` (в модели User), этот запрос выполняется за миллисекунды даже при миллионах записей в истории матчей, обеспечивая пользователям мгновенный вход в игру.
